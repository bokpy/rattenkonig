;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with ‘C-x C-f’ and enter text in its buffer.

Korte analyse en correctie: jouw code probeert BadWindow te voorkomen door `XGetWindowAttributes` te testen, maar deze functie **retourneert altijd 1**, zelfs wanneer het window niet meer bestaat. Daarom werkt jouw check niet. De X-error wordt pas zichtbaar via de Xlib error handler.

**Oplossing: gebruik een tijdelijke error handler rond de calls die kunnen falen.**

Xlib geeft errors niet via returncodes maar via async error events. De enige betrouwbare manier is het “wrappen” van de X-calls met een custom error handler die BadWindow detecteert.

### Correcte aanpak (bewezen werkbaar)

Plaats bovenin:

```c
volatile int had_badwindow = 0;

int temp_xerr_handler(Display *dpy, XErrorEvent *e) {
    if (e->error_code == BadWindow) {
        had_badwindow = 1;
        return 0;
    }
    return 0;
}
```

En wrap de calls:

```c
had_badwindow = 0;
int (*old_handler)(Display*, XErrorEvent*) = XSetErrorHandler(temp_xerr_handler);

XGetWindowAttributes(display, xqp_kid, &attrs);
XSync(display, False);

XSetErrorHandler(old_handler);

if (had_badwindow) {
    // window is invalid
    continue;   // skip this child
}
```

Hetzelfde voor `XQueryPointer`.

### Waarom dit correct is

* `XGetWindowAttributes` retourneert nooit 0, zelfs bij ongeldig window.
* De X-server stuurt een async error die alleen via de error handler kan worden onderschept.
* `XSync` forceert dat de fout *direct* wordt verzonden.

### Compacte patch voor jouw loop

```c
for (unsigned int i = 0; i < xqp_kid_count; i++) {
    xqp_kid = xqp_kid_windows[i];

    had_badwindow = 0;
    old = XSetErrorHandler(temp_xerr_handler);
    XGetWindowAttributes(display, xqp_kid, &attrs);
    XSync(display, False);
    XSetErrorHandler(old);

    if (had_badwindow) {
        continue;   // skip invalid window
    }

    had_badwindow = 0;
    old = XSetErrorHandler(temp_xerr_handler);
    Bool ok = XQueryPointer(display, xqp_kid,
            &dummy_root_win, &xqp_wanted_kid_win,
            &dummy_root_x, &dummy_root_y,
            &dummy_win_x, &dummy_win_y,
            &dummy_mask);
    XSync(display, False);
    XSetErrorHandler(old);
    if (had_badwindow) {
        continue;
    }

    if (ok && xqp_wanted_kid_win) {
        return xqp_wanted_kid_win;
    }
}
```

### Juistheidsschatting

95% (Xlib error-handling gedrag is goed gedocumenteerd en consistent).

Bron: Xlib Programming Manual, hoofdstuk over “Error Handling”.
