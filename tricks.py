#!/usr/bin/env python3
import time
from evdev import InputDevice, categorize, ecodes as ec, list_devices
from collections import defaultdict
import glob
import re
import toys as toy
from icecream import ic

DEBUG=print
error_ic=ic
#ic.configureOutput(prefix, outputFunction, argToStringFunction, includeContext, contextAbsPath)

ic.configureOutput(prefix='Trick: ', includeContext=True)
timeout=12

_int=1
_str=0

'''
dev.capabilities(verbose=True)
{
('EV_SYN', 0): [('SYN_REPORT', 0), ('SYN_CONFIG', 1), ('SYN_MT_REPORT', 2), ('?', 4)], 
('EV_KEY', 1): [(['BTN_LEFT', 'BTN_MOUSE'], 272), ('BTN_RIGHT', 273), ('BTN_MIDDLE', 274), ('BTN_SIDE', 275), ('BT
N_EXTRA', 276)],
 ('EV_REL', 2): [('REL_X', 0), ('REL_Y', 1), ('REL_HWHEEL', 6), ('REL_WHEEL', 8), ('R
EL_WHEEL_HI_RES', 11), ('REL_HWHEEL_HI_RES', 12)],
 ('EV_MSC', 4): [('MSC_SCAN', 4)]
 }
 '''

class MouseCapabilities(dict):
    def __init__(S):
        super().__init__(S)
        S.placeholder_current_id=1025

    def add_placeholder_EV_KEY(S,placeholder):
        if not ec.EV_KEY in S:
            S[ec.EV_KEY]={}
        S[ec.EV_KEY][S.placeholder_current_id]=placeholder
        S.placeholder_current_id+=1
        return S

    def __iadd__(S,O):
        for event_type in O:
            if event_type in S:
                S[event_type].update(O[event_type])
                continue
            S[event_type]=O[event_type].copy()
        return S

    def write_to_file(S,f,func_name_base='event',lower=True):
        print(f'Writing "{S.zip.event_path}" to file')
        for event_type,events in S.items():
            for _,event in events.items():
                func_name=func_name_base +'_'+event
                if lower:
                    func_name=func_name.lower()
                f.write(func_name+'\n')

    def show(S,name='',tabs=''):
        #print(f'"{S.zip.event_path}" MouseCapabilities:')
        if name=='':
            name=S.name
        toy.simple_capablities_show(S,name,tabs+'\t' )
        return S

def button_tester(ignore:int,events:[int])-> dict[int, dict[int, str]]:
    '''
    Test which events are generated by the mouse buttons
    on a mouse device.
    :param ignore: the mouse event
    :type ignore: int
    :param events: list of event numbers to monitor
    :type events: list[int]
    :return: dict {ec.EV_KEY:{event.code:ecodes.BTN or KEY}
    :rtype: dict[int, dict[int, str]]
    '''
    print(f'Press all keys on the device.')
    print(f'press the same key 3x when done.')
    print(f'If there are no keystrokes detected the timeout is {timeout} sec.')

    last_key = -1
    stop_count = 3
    stop_time = time.time() + timeout
    a_key_was_pressed = False
    print (f'button_tester({ignore=},{events=})')

    def stop_test(test_event)->bool:
        """
        Test if the time is up and nothing happened or if
        the user pressed the same button 3 times
        :param event: evdev InputEvent
        :type event: InputEvent
        :return: True stop False continue
        :rtype: bool
        """
        nonlocal a_key_was_pressed,stop_time,stop_count,last_key

        # there is no live sign from these devices check to timeout
        if not test_event and not a_key_was_pressed:
            if time.time() > stop_time:
                print('Key press test timed out')
                return True
        if not test_event:
            return False
        #if it was a key or button press test for the count out
        if test_event.type == ec.EV_KEY and test_event.value:
            a_key_was_pressed = True
            #DEBUG(f'{stop_count } {last_key=} {test_event.code=}')
            if last_key == test_event.code:
                stop_count -= 1
                return stop_count <= 0
            # an other key was pressed restart the countdown
            last_key = test_event.code
            stop_count = 3
        return False

    ev_key_events = {}
    ev_key_events[ec.EV_KEY]={}
    tested_events=ev_key_events[ec.EV_KEY]

    event_count = 0

    def show_status():
        nonlocal tested_events,event_count
        length=len(tested_events)
        if length == event_count:
            return
        print(f'{length:3d} ',end='')
        for code,code_str in tested_events.items():
            print (f'[{code:03d},{code_str}] ',end='')
        event_count=length
        print()

    def handle_event(event):
        nonlocal tested_events,a_key_was_pressed
        if not event or not event.value:
            return False
        if event.type == ec.EV_KEY:
            a_key_was_pressed = True
            bok=toy.BTN_or_KEY_str(event.code)
            code_str=toy.string_event_names(bok)
            #DEBUG(f'Key Event "{code_str}"')
            if not event.code in tested_events:
                tested_events[event.code]=code_str
                show_status()
            #ic(ec.KEY[event.code])
            return True
        if event.type == ec.EV_REL:
            #DEBUG(f'Rel Event "{ec.REL[event.code]}"')
            #test_events[event.type][event.code]=ec.REL[event.code]
            #ic(ec.REL[event.code])
            return True
        return False
        #print(f'{ec.EV[event.type]}:{event.code} not handled.')

    devices=[InputDevice(toy.event_path(event)) for event in events]
    for dev in devices : dev.grab()

    event_ignore=toy.event_path(ignore)
    while True:
        got_somthing=None
        for dev in devices:
            got_somthing = dev.read_one()
            if got_somthing and (event_ignore != dev.path):
                #print(dev)
                handle_event(got_somthing)
                break
        if stop_test(got_somthing):
            break

    for dev in devices:
        dev.ungrab()
    return ev_key_events

def main():

    zip=MouseZip(0)
    zip.show()
    game_caps=MouseCapabilities(zip)


if __name__ == "__main__":
    main()