#!/usr/bin/env python3
import time
from evdev import InputDevice, categorize, ecodes as ec, list_devices
from collections import defaultdict
import glob
import re
import asyncio
import atexit
import toys as toy
from icecream import ic

DEBUG=print
error_ic=ic
#ic.configureOutput(prefix, outputFunction, argToStringFunction, includeContext, contextAbsPath)

ic.configureOutput(prefix='Trick: ', includeContext=True)
timeout=12

_int=1
_str=0

'''
dev.capabilities(verbose=True)
{
('EV_SYN', 0): [('SYN_REPORT', 0), ('SYN_CONFIG', 1), ('SYN_MT_REPORT', 2), ('?', 4)], 
('EV_KEY', 1): [(['BTN_LEFT', 'BTN_MOUSE'], 272), ('BTN_RIGHT', 273), ('BTN_MIDDLE', 274), ('BTN_SIDE', 275), ('BT
N_EXTRA', 276)],
 ('EV_REL', 2): [('REL_X', 0), ('REL_Y', 1), ('REL_HWHEEL', 6), ('REL_WHEEL', 8), ('R
EL_WHEEL_HI_RES', 11), ('REL_HWHEEL_HI_RES', 12)],
 ('EV_MSC', 4): [('MSC_SCAN', 4)]
 }
 '''

class MouseCapabilities(dict):
    def __init__(S):
        super().__init__(S)
        S.placeholder_current_id=1025

    def add_placeholder_EV_KEY(S,placeholder):
        if not ec.EV_KEY in S:
            S[ec.EV_KEY]={}
        S[ec.EV_KEY][S.placeholder_current_id]=placeholder
        S.placeholder_current_id+=1
        return S

    def __iadd__(S,O):
        for event_type in O:
            if event_type in S:
                S[event_type].update(O[event_type])
                continue
            S[event_type]=O[event_type].copy()
        return S

    def add(S,ev_type,event_dict):
        if ev_type in S:
            S[ev_type].update(event_dict)
            return S
        S[ev_type]=event_dict
        return S

    def write_to_file(S,f,func_name_base='event',lower=True):
        #print(f'Writing "{S.zip.event_path}" to file')
        for event_type,events in S.items():
            for _,event in events.items():
                func_name=func_name_base +'_'+event
                if lower:
                    func_name=func_name.lower()
                f.write(func_name+'\n')

    def show(S,name='',tabs=''):
        #print(f'"{S.zip.event_path}" MouseCapabilities:')
        if name=='':
            name=S.name
        toy.simple_capablities_show(S,name,tabs+'\t' )
        return S

# key press tasting
grabed_devices=None
key_events=[]

def atexit_ungrab():
    global grabed_devices
    if not grabed_devices:
        return
    for device in grabed_devices:
        print(f'Ungrab: "{device.name}"')
        device.ungrab()

async def read_device(dev):
    global grabed_devices,key_events
    stopper=2
    previous_key_event=-1
    key_events=[]

    async for event in dev.async_read_loop():
        if event.type == ec.EV_KEY and event.value==1:
            if event.code == previous_key_event:
                stopper-=1
                if stopper < 0:
                    raise Exception("Stop read device",798)
                    #return key_events
            else:
                stopper=2
                previous_key_event=event.code
            if toy.is_BTN(event.code):
                print(f'{ec.BTN[event.code]}')
            elif toy.is_KEY(event.code):
                if not event.code in key_events:
                    key_events.append(event.code)
                    print(f'{len(key_events):2d} {ec.KEY[event.code]}')

async def run_tasks():
    global grabed_devices
    tasks = [asyncio.create_task(read_device(d)) for d in grabed_devices]
    await asyncio.gather(*tasks)

def button_tester(events:[int])-> dict[int, str]:
    global grabed_devices,key_events
    print(f'Press all keys on the device.')
    print(f'press the same key 3x when done.')
    print(f'If there are no keystrokes detected the timeout is {timeout} sec.')
    grabed_devices = [InputDevice(toy.event_path(event)) for event in events]
    for device in grabed_devices:
        device.grab()
    atexit.register(atexit_ungrab)
    try:
        asyncio.run(run_tasks())
    except Exception as e:

        ic(e)

    for device in grabed_devices:
        print(f'Tester Ungrab : {device.path} "{device.name}"')
        device.ungrab()
    atexit.unregister(atexit_ungrab)
    grabed_devices=None
    return key_events

#     for dev in devices : dev.grab()
#
#     '''
# def button_tester(events:[int])-> dict[int, str]:
#     '''
#     Test which key events are generated by some of the mouse buttons.
#
#     :param events: list of event numbers to monitor
#     :type events: list[int]
#     :return: dict{event.code:ecodes.KEY}
#     :rtype: dict[int, str]
#     '''
#     print(f'Press all keys on the device.')
#     print(f'press the same key 3x when done.')
#     print(f'If there are no keystrokes detected the timeout is {timeout} sec.')
#
#     last_key = -1
#     stop_count = 2
#     stop_time = time.time() + timeout
#     occurrence_detected = False
#     devices=[]
#
#     def stopper(test_event)->bool:
#         """
#         Test if the time is up and nothing happened or if
#         the user pressed the same button 3 times
#         :param event: evdev InputEvent
#         :type event: InputEvent
#         :return: True stop False continue
#         :rtype: bool
#         """
#         nonlocal occurrence_detected,stop_time,stop_count,last_key
#
#         # there is no live sign from these devices check to timeout
#         if not occurrence_detected and ( time.time() > stop_time):
#                 print('Key press test timed out')
#                 return True
#         if not test_event:
#             return False
#         #if it was a key or button press test for the count out
#         if (test_event.type == ec.EV_KEY) and test_event.value:
#             #ic(stop_count,last_key,test_event.code)
#             if last_key == test_event.code:
#                 stop_count -= 1
#                 ic(stop_count)
#                 return stop_count <= 0
#             # an other key was pressed restart the countdown
#             last_key = test_event.code
#             stop_count = 2
#         return False
#
#     key_events={}
#     tested_events=[]
#     event_count = 0
#
#     def handle_event(event):
#         nonlocal tested_events,occurrence_detected,event_count
#         if not event or not event.value:
#             return False
#         all_test=all([event.type == ec.EV_KEY
#                    ,toy.is_KEY(event.code)
#                    ,not event.code in tested_events])
#         ic(all_test)
#         if all([event.type == ec.EV_KEY
#                    ,toy.is_KEY(event.code)
#                    ,not event.code in tested_events])  :
#             if toy.is_KEY(event.code):
#                 if not (event.code in tested_events):
#                     event_name=toy.string_event_names(ec.KEY[event.code])
#                     key_events[event.code]=event_name
#                     tested_events.append(event.code)
#                     toy.string_event_names(ec.KEY[event.code])
#                     event_count+=1
#                     print(f'{event_count:3d} [{event.code}:"{event_name}" detected.')
#                 else:
#                     print("#",end='')
#             elif toy.is_BTN(event.code):
#                 print("*",end='')
#         return True
#
#     def ungrab_devices():
#         nonlocal devices
#         for dev in devices: dev.ungrab()
#
#     devices=[InputDevice(toy.event_path(event)) for event in events]
#     for dev in devices : dev.grab()
#
#     while True:
#         got_somthing=None
#         for dev in devices:
#             got_somthing = dev.read_one()
#             if got_somthing:
#                 occurrence_detected = True
#                 print(f'{dev.name} {got_somthing}')
#                 break
#         handle_event(got_somthing)
#         if stopper(got_somthing):
#             ungrab_devices()
#             return key_events
#
#     ungrab_devices()
#     return key_eventsun

def test_button_tester():
    result = button_tester([17, 18, 19, 20])
    ic(result)

def main():
    test_button_tester()
    #game_caps=MouseCapabilities(zip)


if __name__ == "__main__":
    main()